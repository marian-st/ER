\documentclass[final, smallexted]{svjour3}
%opening
\usepackage[11pt]{extsizes}
\usepackage[top=2cm,bottom=3cm,left=2.3cm,right=2.3cm]{geometry}

\title{Relazione progetto di Ingegneria del software 2019}
\author{Edoardo Zorzi, Elia Piccoli, Marian Statache}
\date{Luglio 2019}
\usepackage{tikz}
\usepackage{xcolor}
\usepackage{pgfopts}
\usepackage{./tikz-uml}
\usepackage[latin1]{inputenc}
\usepackage[italian]{babel}
\usepackage[T1]{fontenc}
\usetikzlibrary{automata ,shapes, er, arrows,chains,positioning,scopes,quotes,decorations.markings,shapes.multipart,shapes.callouts}
\usepackage{dot2texi}
\usepgfmodule{oo}
\usepackage{lscape}
\tikzset{singlestate/.style={draw, rounded corners,
		minimum width=15mm, minimum height=6mm,
		align=center, inner sep=1mm, outer sep=0mm,}}

\usepackage{./usecases}

\tikzset{multi attribute/.style={attribute,double distance=1.5pt}} \tikzset{derived attribute/.style={attribute ,dashed}} \tikzset{total/.style={double distance=1.5pt}}
\tikzset{every entity/.style={draw=orange, fill=orange!20}}
\tikzset{every attribute/.style={draw=mediumpurple, fill=mediumpurple!20}} \tikzset{every relationship/.style={draw=Chartreuse2, fill=Chartreuse2!20}} \newcommand{\key}[1]{\underline{#1}}

\definecolor{mediumpurple}{rgb}{0.58, 0.44, 0.86}
\definecolor{Chartreuse2}{rgb}{0.5, 1.0, 0.0}
\begin{document}

\maketitle


\section{Ingegneria e sviluppo}
\subsection{Organizzazione iniziale del processo di sviluppo}

\paragraph{Decisioni organizzative}
La dimensione del team di sviluppo --- tre persone --- e i diversi livelli di interesse relativi agli `ambiti' di programmazione concernenti tale progetto, espressi inizialmente dai soggetti del team, hanno portato alla decisione di suddividere in modo moderatamente netto i compiti assegnati alle diverse persone, perlomeno nella fase iniziale, pre-design. 

Specificatamente, la decisione è stata quella di assegnare a Marian il compito di creare e sviluppare la interfacce grafiche di tutti i componenti costituenti il sistema nel suo complesso e quello di ideare e sviluppare la GUI generale, e in particolar modo di considerare i modi con cui gli utenti si aspettano di interagire con il sistema e quindi di sviluppare accordatamente le relative interfacce grafiche.

Ad Elia ed Edoardo invece è stato assegnato il compito di progettare e sviluppare la back-end, l'architettura del sistema generale e le interfacce di comunicazione e interazione dei diversi componenti. Pur non avendo definito inizialmente la suddivisione ulteriore di questi compiti, nel corso del processo di sviluppo e programmazione del sistema, a seguito della fase di progettazione in cui si sono prese decisioni relative a quali design patterns usare, la progettazione dell'architettura è stata a grandi linee divisa in due aree: lo sviluppo dei controllori e dei modelli dei componenti, secondo il pattern MVC, assegnata ad Elia, e lo sviluppo e gestione dello stato centralizzato, propagato poi seguendo il pattern Observer, assegnata invece ad Edoardo. Data la fondamentale connessione tra tali due aree da un certo punto in poi lo sviluppo dell'architettura, e in particolar modo dell'interfaccia di comunicazione tra stato e controllori dei componenti, è stata eseguita in modo unico dai i due membri del team che hanno seguito quasi esclusivamente la tecnica del \textit{dual programming}, che ha portato a scrivere gran parte del codice insieme, a turno, uno con l'input dell'altro: questo sia per permettere di migliorare la comprensione dell'architettura nel suo complesso e delle interazioni tra le parti, sia per permettere di sviluppare codice che sin da subito rispettasse i due diversi approcci di programmazione e che unisse nel modo più chiaro possibile le interfacce tra le due aree.

\paragraph{Gestione del codice} Per permettere, soprattutto inizialmente, a tutti i membri del team di contribuire al progetto in modo personale senza creare conflitti nel codice si è deciso sin da subito di utilizzare un sistema di versionamento: la scelta è ricaduta subito su \textit{Git}, data la sua ubiquità e portabilità, installato localmente sulle macchine dei membri del team e riferente una repository remota privata localizzata su \textit{Github}. Oltre che a permettere di evitare conflitti e di mantenere coerente lo stato del progetto per tutti i membri questa scelta è stata molto importante soprattutto per risolvere diversi problemi relativi all'installazione e utilizzo di un programma per la gestione del database: l'uso di diverse \textit{branches}, utilizzate anche per lo sviluppo di parti sperimentali del sistema, ha permesso lo sviluppo in contemporanea, almeno fino alla risoluzione di tutti i problemi di installazione e configurazione, del codice concernente la gestione del database e di quello relativo alle interfacce grafiche e i loro controllori.

\paragraph{Gestione dei dati} La chiara natura relazionale dei dati necessari per il funzionamento del sistema ha subito portato alla decisione di affidarsi ad un RDBMS per la loro gestione, e in particolare a PostgreSQL; tale scelta è stata motivata principalmente dalla previa esperienza di utilizzo di un membro del team. Oltre che ad utilizzare un RBDMS si è inoltre deciso di affidarsi ad un ORM --- Hibernate --- per il mapping tra entità nel database e oggetti in memoria: questa decisione è derivata soprattutto dalla volontà di mantenere semplice la logica del sistema che, per sua natura e limitata dimensione, non ha mai richiesto la maggior efficienza derivante dall'utilizzo di pure query SQL. 

\subsection{Ingegneria dei requisiti}
Data la natura didattica del progetto non si sono seguite le classiche tecniche di elicitazione dei requisiti ma essi sono stati ricavati e studiati a partire dalla specifica di consegna, considerata, almeno in parte, come documento dei requisiti. La stesura iniziale delle principali funzionalità, sotto forma di un provvisorio schema dei casi d'uso, è stata eseguita nella fase di pre-design da parte di tutti i membri del team basandoci appunto su tale documento dei requisiti.

Nel corso dello sviluppo del progetto, a seconda delle diverse funzionalità da implementare, sono anche stati stilati diversi casi d'uso per i vari utenti finali secondo un processo simile a quello adottato dai modelli agili: prima di implementare funzionalità specifiche del sistema si è pensato ad almeno un caso d'uso reale di tali funzionalità per permettere poi un'implementazione quanto più semplice, naturale e rispettante le aspettative e necessità degli utenti.

Di seguito parte dei casi d'uso utilizzati, aggregati per chiarezza nei vari utenti finali.

\vspace{.5cm}
\subsection*{\textbf{Primario}}\hrule
\vspace{1cm}
\begin{usecase}
	\addtitle{Caso d'uso}{Compilazione lettera di dimissioni}
	\addfield{Utente:}{Primario}
	\addfield{Precondizioni:}{Il primario deve essersi autenticato}
	\additemizedfield{Passi}{
		\item Nella propria dashboard seleziona la finestra per compilare le lettere di dimissioni
		\item Seleziona da un menù a tendina i pazienti ricoverati in attesa di essere dimessi
		\item Visualizza nella schermata i dati sommari del ricovero e compila la lettera di dimissione, e conferma la dimissione premendo il tasto di conferma
	}
	\addfield{Postcondizioni:}{Il paziente viene dimesso e il suo ricovero non compare più nel menù}
	
\end{usecase}

\begin{usecase}
\addtitle{Caso d'uso}{Visualizzazione e stampa dei reports dei ricoveri}
\addfield{Utente:}{Primario}
\addfield{Precondizioni:}{Il primario deve essersi autenticato}
\additemizedfield{Passi}{
	\item Nella propria dashboard seleziona la finestra per visualizzare i reports dei ricoveri settimanali
	\item Seleziona da un menù a tendina, o tramite ricerca, i ricoveri settimanali, attivi o non attivi 
	\item Visualizza nella schermata i dati sommari dei ricoveri e dei pazienti. Eventualmente può stampare tali report cliccando su un pulsante che genera un documento pdf
}
\addfield{Postcondizioni:}{Vengono visualizzati i reports dei ricoveri settimanali. Se il primario ha premuto il bottone per stamparli, viene generato un documento pdf con i dati richiesti}

\end{usecase}

\begin{usecase}
	\addtitle{Caso d'uso}{Visualizzazione dati dei pazienti ricoverati (ultime due ore)}
	\addfield{Utente:}{Primario, medico, infermiere}
	\addfield{Precondizioni:}{L'utente deve essersi autenticato}
	\additemizedfield{Passi}{
		\item Nella propria dashboard l'utente seleziona la finestra per visualizzare i dati dei pazienti ricoverati
		\item L'utente visualizza, in una tabella, i dati aggiornati in tempo reale, ed esclusivi delle ultime due ore, di tutti i pazienti ricoverati
	}
	\addfield{Postcondizioni:}{L'utente visualizza le informazioni, non più vecchie di due ore, sui parametri vitali dei pazienti ricoverati}
\end{usecase}
\vspace{1cm}

\subsection*{\textbf{Medico}}\hrule
\vspace{1cm}
\begin{usecase}
	\addtitle{Caso d'uso}{Spegnimento allarme}
	\addfield{Utente:}{Medico}
	\addfield{Precondizioni:}{Deve essere partito un allarme}
	\additemizedfield{Passi}{
		\item In un finestra compaiono informazioni circa il paziente e la condizione segnalata
		\item Indica le attività svolte per portare il paziente alla normalità
		\item \begin{enumerate}
			\item se è gia autenticato, spegne l'allarme
			\item se non è autenticato, spegne l'allarme indicando le proprie credenziali
		\end{enumerate}
	}
	\addfield{Postcondizioni:}{L'allarme viene spento. Se il medico non era autenticato e ha inserito correttamente le sue credenziali rimarrà autenticato per un certo periodo di tempo}
	
\end{usecase}

\begin{usecase}
	\addtitle{Caso d'uso}{Ammissione dei pazienti in attesa}
	\addfield{Utente:}{Medico}
	\addfield{Precondizioni:}{Il medico deve essersi autenticato; un infermiere deve avere aggiunto i dati anagrafici dei pazienti in attesa di ricovero}
	\additemizedfield{Passi}{
		\item Nella propria dashboard seleziona la finestra per visualizzare i pazienti in attesa di ricovero
		\item Da un menù a tendina sceglie tra i diversi pazienti in attesa, visualizzando informazioni sommarie
		\item Se accetta di ammetterlo, da un campo di testo inserisce la diagnosi e preme un bottone di conferma
		\begin{enumerate}
			\item se il numero di pazienti attualmente ricoverati è minore di dieci, viene ammesso
			\item altrimenti compare una finestra di errore
		\end{enumerate}
	}
	\addfield{Postcondizioni:}{Se il numero di pazienti attualmente ricoverati è minore di dieci e ha accettato di ammetterne uno inserendo la diagnosi, allora il nome del paziente scompare dal menù a tendina ed esso sarà compreso tra quelli ricoverati}
	
\end{usecase}

\begin{usecase}
	\addtitle{Caso d'uso}{Aggiunta di prescrizioni}
	\addfield{Utente:}{Medico}
	\addfield{Precondizioni:}{Il medico deve essersi autenticato; il paziente a cui si aggiunge una prescrizione deve essere ricoverato}
	\additemizedfield{Passi}{
		\item Nella propria dashboard seleziona la finestra per aggiungere una prescrizione
		\item Da un menù a tendina sceglie tra i diversi pazienti attualmente ricoverati, visualizzando, a seconda della selezione, informazioni sommarie sul paziente
		\item In diversi campi di testo aggiunge il nome del medicinale, la dose giornaliera, la quantità per dose e la durata della terapi e preme il pulsante di conferma
	}
	\addfield{Postcondizioni:}{La prescrizione viene aggiunta a quelle associate al paziente ricoverato.}
	
\end{usecase}


\subsection*{\textbf{Infermiere}}\hrule


\begin{usecase}
	\addtitle{Caso d'uso}{Compilazione dati anagrafici paziente}
	\addfield{Utente:}{Infermiere}
	\addfield{Precondizioni:}{L'infermiere deve essersi autenticato}
	\additemizedfield{Passi}{
		\item Nella propria dashboard seleziona la finestra per inserire i dati anagrafici dei pazienti
		\item In diversi campi di testo aggiunge i dati anagrafici del paziente, tra cui nome, congnome, luogo e data di nascita. Premendo un pulsante può generare, sulla base di tali dati, il codice fiscale corretto del paziente
	}
	\addfield{Postcondizioni:}{Il paziente è inserito in stato di attesa}
	
\end{usecase}

\begin{usecase}
	\addtitle{Caso d'uso}{Aggiunta di somministrazioni}
	\addfield{Utente:}{Infermiere}
	\addfield{Precondizioni:}{L'infermiere deve essersi autenticato; il paziente a cui viene aggiunta una somministrazione deve essere ricoverato e avere almeno una prescrizione registrata}
	\additemizedfield{Passi}{
		\item Nella propria dashboard seleziona la finestra per aggiungere una somministrazione
		\item Seleziona da un menù a tendina il paziente e il medicinale prescritto per cui può aggiungere una somministrazione
		\item Visualizza nella schermata i dati sommari della prescrizione, tra cui le massime dosi giornaliere; in un campo di testo può inserire note circa la somministrazione e la conferma premendo un pulsante
	}
	\addfield{Postcondizioni:}{La somministrazione è aggiunta al paziente, associata alla data prescrizione}
	
\end{usecase}

\subsection{Design del sistema}
La scelta di design iniziale del sistema è stata fatta a tavolino tra tutti i membri del team prima di implementare qualsiasi funzionalità. Dopo aver letto attentamente la specifica e aver redatto lo schema dei casi d'uso, provvisorio, si sono discussi diversi possibili approcci e in particolare si è cercato di determinare se e quali \textit{design patterns} fossero i più adatti da usare al fine di costruire il sistema generale. 

Dopo diverse discussioni e lavoro di gruppo e individuale si è deciso a grandi passi di adottare una architettura generalmente simile a quella adottata da alcuni frameworks di sviluppo web: un sistema centralizzato (\textit{repository}) di gestione e salvataggio dello stato che ad ogni modifica è propagato a tutta l'applicazione in ascolto e che si aggiorna in modo asincrono (\textit{observer pattern}); componenti decentralizzati, creati da \textit{factories} adoperate dal sistema centrale, che rappresentano singole finestre e che comprendono sia la \textit{view}, cioè quello che vede l'utente, sia la business logic (\textit{controller}) che determina come si reagisce alle diverse interazioni e modifiche dello stato centrale, oltre che ai dati (\textit{model}) ottenuti e aggiornati centralmente dal gestore dello stato --- \textit{pattern MVC}.

Oltre a questo è stato spesso fatto uso della \textit{dependency injection} per garantire una maggiore modularità dei componenti e limitare la dipendenza da classi statiche e stato nascosto, spesso rischioso e prono ad errori.
 \textcolor{red!70!black}{***TODO (spiegazione del design dello stato, completa patterns)***} %TODO 

\begin{figure}[b]
	\begin{tikzpicture}[scale=.9] \begin{umlseqdiag}
	\umlobject[class=Controller, ] {a} 
	\umlobject[class=Store] {b}
	\umlobject[class=Controller]{c}
	\umlobject[class=Reducer]{d}
	\umlobject[class=Middleware]{e}
	\begin{umlcall}[op={\scriptsize{subscribe(f1: Function)}}, type=asynchron, dt=6] {a}{b} 
	\end{umlcall}
	\begin{umlcall}[op={\scriptsize{subscribe(f2: Function)}}, type=asynchron, dt=12] {c}{b} 
	\end{umlcall}
	\begin{umlcall}[op={\scriptsize{update(c: Command)}}, type=asynchron, dt=9] {c}{b}
	\end{umlcall}
	\begin{umlcall}[op={\scriptsize{run(c: Command , s:  State)}}, dt=6, return={\scriptsize{s: State}}]{b}{d}
	\end{umlcall}
	\begin{umlcall}[op={\scriptsize{run(c: Command, s: State)}}, dt=7, return={\tiny{sc: (Command, State)}}]{b}{e}
	\end{umlcall}
	\begin{umlcall}[op={\scriptsize{f1 (sc)}}]{b}{a}
	\begin{umlcall}[op={\scriptsize{f2 (sc)}}]{b}{c}
	\end{umlcall}
	\end{umlcall}
	\end{umlseqdiag} \end{tikzpicture}\caption{\textit{Sequence diagram} dell'interazione di due generici controller con lo stato centralizzato gestito dallo Store, che usa un Reducer e Middleware per trasformare lo stato e trasmetterlo asincronicamente a tutti i controllori registrati tramite \textit{subcribe()}.}
\end{figure}

\subsection{Implementazione}
 Heila \textcolor{red!70!black}{***TODO***} %todo
 
\subsection{Validazione e verifica}
Le operazioni di validazione e verifica sono state fondamentali per garantire che il progetto rispettasse la specifica e i requisiti, e che si comportasse in modo coerente e prevedibile, senza errori, a tutti gli input previsti e operazioni eseguibili degli utenti.

\paragraph{Validazione}Le operazioni di validazione sono state eseguite facendo un check periodico, dopo ogni implementazione di funzionalità non triviali, del rispetto della specifica per verificare sia che tutti i vincoli temporali e di caratteristiche dei dati fossero rispettati (come ad esempio i tipi di ricovero da visualizzare o le informazioni sui parametri vitali dei pazienti, limitati a dati intervalli temporali), sia che tali funzionalità corrispondessero a quello richiesto dal software finale.
Questo è stato soprattutto importante dopo l'implementazione delle funzionalità di ogni utente: data la non modesta quantità di funzioni da mettere a disposizione e dati da considerare/manipolare in molti casi il check di verifica eseguito successivamente ha messo alla luce rilevanti criticità e importanti modifiche da implementare. 
Oltre a queste verifiche periodiche si è anche eseguito un controllo finale, al ridosso della scadenza, per validare il sistema nel suo complesso e cercare di individuare eventuali omissioni e elementi non completamente rispettosi della specifica e dei requisiti.
\begin{figure}[t]
	\begin{tikzpicture} 
	\umlstateinitial[x=0, name=A];
	\umlstatedecision[x=1.5,name=dec];
	\node[singlestate, name=B] at(4.2,0) {Design funzionalità};
	\node[singlestate, name=C] at(8.1,0) {Implementazione};
	\node[singlestate, name=D] at(11.4,0) {Validazione};
	\umlstatedecision[x=13.8, name=decision]
	
	\umltrans[arm1=0cm, pos =1.5 ] {A}{dec}
	\umltrans[]{dec}{B}
	\umltrans[]{B}{C}
	\umltrans[]{C}{D}
	\umltrans[arg=Ok?]{D}{decision}
	\umlVHVtrans[arm1=-1cm, arg=No]{decision}{dec}
	\umlstatefinal[x=15.5, name=final]
	\umltrans[arg=Sì]{decision}{final}
	\end{tikzpicture}\caption{\textit{Activity diagram} della fase di validazione per le funzionalità dei componenti utente.}
\end{figure}
\paragraph{Verifica} Molto importante è stata anche la verifica della correttezza del programma che data la sua non banale complessità ha mostrato spesso comportamenti sbagliati in fase di programmazione. A tal fine si è deciso di operare nel seguente modo: \begin{itemize}
	\item una fase di \textit{development testing} utilizzando \textit{unit tests} per tutte quelle classi e aree di più facile testabilità automatica: quelle meno dipendenti dagli input specifici dell'utente, eseguite dall'interfaccia grafica, e dall'integrazione con altri oggetti del sistema. Essi sono stati eseguiti affindandosi ad una libreria esterna, \textit{JUnit4}, e sono stati principalmente usati per verificare il comportamento del package \textit{State}, della classe \textit{Sistema} e \textcolor{red!70!black}{***TODO (completa qui e aggiungi test sistema, non uso di testdriven development)***}
	\item una fase di \textit{release testing} dove si è cercato di testare tutti i comportamenti possibili degli utenti finali simulando diverse casistiche e flow di lavoro per verificare che il sistema gestisse correttamente gli input. In particolare si è testato il corretto comportamento di tutti i pulsanti e dei menù e si è verificato che le diverse entità, consistenti lo stato del sistema, fossero correttamente gestite, manipolate, e visualizzate nelle diverse view degli utenti. Questo tipo di test è stato eseguito a parte da tutti i membri del team cercando di simulare il comportamento di un soggetto non tecnico.
	\item una fase di \textit{user testing} dove si è fatto testare il software ad un soggetto di media/moderata abilità informatica per verificare l'usabilità del programma di fronte ad input reali e sostanzialmente conformi a quelli che ci si aspetta da soggetti normali che utilizzerebbero in modo coerente il programma. Questa fase è stata molto utile per implementare piccole migliorie all'usabilità del programma come ad esempio un ritocco del comportamento dei menù a tendina, modifiche ad alcune tabelle --- al fine di includere dati differenti o formattati diversamente --- e anche lievi cambiamenti alla struttura e disposizione degli elementi dell'interfaccia grafica (tipo rendere alcuni pulsanti non attivi, cambiare alcune grafiche etc.). 
\end{itemize}

%\subsection{Design e struttura del sistema}
%
%\section{Specifica del sistema}

\section{Specifica}
\subsection{Casi d'uso}
\begin{figure}[b]
\begin{tikzpicture}
\begin{umlsystem}[x=0, fill=red!5]{Casi d'uso}
\umlusecase[x=1, y=-2.45]{Inserisce dati anagrafici del paziente}
\umlusecase[ x=.95, y=-1]{Inserisce dati somministrazione}
\umlusecase[x=4.8, ]{Inserisce note stato paziente}
\umlusecase[y=-6.5, x =2.6]{Visualizza dati paziente (ultime due ore)}
\umlusecase[x=5, y=-5.3]{Inserisce diagnosi d'ingresso}
\umlusecase[x=5.7, y=-4.3]{Aggiunge prescrizioni}
\umlusecase[x=6.3,  y=-7.5]{Spegne allarmi}
\umlusecase[x=.6, y=-9.4]{Visualizza/stampa reports pazienti}
\umlusecase[x=0, y=-10.8]{Compila lettera di dimissioni}
\end{umlsystem}

\umlactor[x=-5.5, y=-1.6]{Infermiere}
\umlactor[x=-5.5, y=-9.7]{Primario}
\umlactor[x=10.4, y=-5.7]{Medico}

\umlassoc{Infermiere}{usecase-1}
\umlassoc{Infermiere}{usecase-2}
\umlassoc{Infermiere}{usecase-4}

\umlassoc{Medico}{usecase-4}
\umlassoc{Medico}{usecase-5}
\umlassoc{Medico}{usecase-6}
\umlassoc{Medico}{usecase-7}

\umlassoc{Primario}{usecase-4}
\umlassoc{Primario}{usecase-8}
\umlassoc{Primario}{usecase-9}
\umlVHinclude{usecase-1}{usecase-5}
%\umlassoc{subuser}{usecase-3}
%\umlassoc{admin}{usecase-5}
%\umlassoc{admin}{usecase-6}
\umlinclude{usecase-2}{usecase-6}
\node at(4.1, -3.35) {$\ll$include$\gg$};
\umlVHextend{usecase-3}{usecase-2}
%\umlinclude[name=incl]{usecase-3}{usecase-4}
%
%\umlnote[x=7, y=-7]{incl-1}{note on include dependency}
\end{tikzpicture}\caption{Diagramma UML dei casi d'uso del sistema.}\label{useDiagram}
\end{figure}

\subsection{Diagrammi di classe}
\begin{figure}
	\begin{center}
		\begin{tikzpicture}
		\begin{umlpackage}[ x=0, y=0]{State}
		\umlclass[x=5.5, template={C}]{Store} {- s: State\\- r: Reducer \\- m: Middleware}{+ poll(): State \\ + update(com: C)}
		
		\umlinterface[x=0, y=-3, template={C}]{Reducer}{}{+ run(s: State, c: C): State \\+ with(s: String, f: Function) }
		\umlsimpleclass[x=0, y=-6]{ReducerString}{}{}
		
		\umlinterface[x=11, y=-3 , template={C}]{Middleware}{}{+ run(s: State, c: C) \\ + with(s: String, f: Function)}
		\umlsimpleclass[x=11, y=-6]{MiddlewareString}{}{}
		
		\umlsimpleclass[x=5.5, y=-3.5]{State} {}{}
		\umlsimpleclass[x=5.5, y=-6, template={C}]{StateEvent}{}{}
		
		\umlinterface[ y=-9, x=5.5]{Command}{}{+ name(): String \\+ getArg(): Object}
		\umlsimpleclass[x=0.2, y=-9]{StringCommand}
		
		\umlsimpleclass[x=11.8, y=0]{DatabaseService}{}{}
		
		\umlreal[]{MiddlewareString}{Middleware}
		\umlreal[]{ReducerString}{Reducer}
		\umlreal[]{StringCommand}{Command}
		\umldep[geometry=-|-]{Reducer}{Store}
		\umldep[geometry=-|-]{Middleware}{Store}
		\umldep[geometry=-|]{State}{Store}
		\umldep[]{State}{StateEvent}
		\umldep[]{Command}{StateEvent}
		\end{umlpackage}  
		
		\end{tikzpicture}
	\end{center}\caption{Diagramma di classe del \textit{package} State.}\label{StateClassDiagram}
\end{figure}

\begin{figure}
	\begin{center}
		\begin{tikzpicture}
		\begin{umlpackage}[ x=0, y=0]{Generator}
		
		\umlinterface[x=6.25, y=0]{GeneratorInterface}{}{+ reset() \\ + evolve(sick: Sickness) \\ + getValue(): Object}
	
		
		\umlclass[x=0, y=-4]{BPGenerator}{- canGenerateAlarm \\ - meanS \\ - meanD \\ - varianceS \\ - varianceD}{}
		\umlclass[x=6.25, y=-4]{TemperatureGenerator}{- canGenerateAlarm \\ - mean \\ - variance}{}
		\umlclass[x=12.5, y=-4]{HeartrateGenerator}{- canGenerateAlarm \\ - mean \\ - variance}{}
		\umlreal[geometry=|-]{BPGenerator}{GeneratorInterface}
		\umlreal[geometry=|-]{HeartrateGenerator}{GeneratorInterface}
		\umlreal[]{TemperatureGenerator}{GeneratorInterface}
		\end{umlpackage}  
		
		\end{tikzpicture}
	\end{center}\caption{Diagramma di classe del \textit{package} Generator.}\label{GeneratorClassDiagram}
\end{figure}

\begin{figure}
	\begin{center}
		\begin{tikzpicture}
		\begin{umlpackage}[ x=0, y=0]{HPInterfaceFactory}
		\umlclass[x=7, y=3.5]{HPFactory}{}{+ getHPFactory(s: String)}
		\umlinterface[x=7, y=0]{HPInterface}{}{+ getFile() : String }
		
		\umlsimpleclass[x=0, y=-3]{HPDefault}
		\umlsimpleclass[x=4.4, y=-3]{HPMonitoring}
		\umlsimpleclass[x=9.2, y=-3]{HPSearch}
		\umlsimpleclass[x=13.2, y=-3]{HPSearchResult}
		
		\umlimpl[geometry=|-]{HPDefault}{HPInterface}
		\umlimpl{HPMonitoring}{HPInterface}
		\umlimpl{HPSearch}{HPInterface}
		\umlimpl[geometry=|-]{HPSearchResult}{HPInterface}
		\end{umlpackage}  
		
		\end{tikzpicture}
	\end{center}\caption{Diagramma di classe del \textit{package} HPInterfaceFactory.}\label{HpInterfaceFactoryClassDiagram}
\end{figure}

\begin{figure}
	\begin{center}
\begin{tikzpicture}[node distance=7em]
\node[entity] at (0,0) (patient) {Patient};
\node[relationship] (riceve) at(3.2,0) {receives} edge (patient); 
\node[entity] (administration) at (6.7,0) {Administration} edge (riceve); 
\node[relationship] (has) [below of=administration] {has} edge(administration);
\node[entity] (prescription) [below of=has] {Prescription} edge(has);
\node[relationship] (comprehends) at (3.2,-5) {includes} edge(prescription);
\node[entity] (recovery) at (0, -5) {Recovery} edge(comprehends);
\node[relationship] (getput) [below of=patient] {gets put} edge(patient) edge(recovery);
\node[relationship] (includes) [below of=recovery] {includes} edge(recovery);
\node[entity] (monitoring) [below of=includes] {Monitoring} edge(includes);

\node at (1.1,0.25) {1};
\node at (5.1,0.25) {n};

\node at (6.95,-0.8) {n};
\node at (6.95,-4.1) {1};

\node at (0.3,-0.8) {1};
\node at (0.3,-4.2) {n};

\node at (1.2,-4.7) {1};
\node at (5.3,-4.7) {n};

\node at (0.3,-5.8) {1};
\node at (0.3,-9.2) {n};

\end{tikzpicture}
	\end{center}
	\caption{Schema \textit{Entity-Relationship} dei dati del sistema.}\label{ERdiagram}
\end{figure}
\begin{figure}
	
		\begin{tabular}{r | l}
			Entità & Campi \\ \hline
			Patient & \underline{Id}, Name, Surname, Fiscal code, Place of birth, Date of birth, Patient state \\
			Administration & \underline{Id}, Date, Hour, Dose, Notes, \textit{Patient}, \textit{Prescription} \\
			Prescription & \underline{Id}, Drug, Duration, Daily dose, Number of doses, Doctor, \textit{Recovery} \\ 
			Recovery & \underline{Id}, Start date, End date, Diagnosis, Active, Discharge summary, Recovery state, \textit{Patient}\\
			Monitoring & \underline{Id}, Date, Diastolic pressure, Systolic pressure, Heart rate, Temperature, \textit{Recovery}
		\end{tabular}\caption{Campi e relazioni delle entità del database. I campi sottolineati indicano le \textit{primary keys}, quelli in corsivo le \textit{foreign keys} (mappate sempre ai campi Id della rispettiva entità).}

\end{figure}



\end{document}
