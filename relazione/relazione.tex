\documentclass[final, smallexted]{svjour3}
%opening
\usepackage[11pt]{extsizes}
\usepackage[top=2cm,bottom=3cm,left=2.3cm,right=2.3cm]{geometry}

\title{Relazione progetto di Ingegneria del software 2019}
\author{Edoardo Zorzi, Elia Piccoli, Marian Statache}
\date{Luglio 2019}
\usepackage{tikz}
\usepackage{xcolor}
\usepackage{pgfopts}
\usepackage{./tikz-uml}
\usepackage[latin1]{inputenc}
\usepackage[italian]{babel}
\usepackage[T1]{fontenc}
\usetikzlibrary{automata ,shapes, er}
\usepackage{dot2texi}
\usepgfmodule{oo}
\usepackage{lscape}
\usepackage{./usecases}

\tikzset{multi attribute/.style={attribute,double distance=1.5pt}} \tikzset{derived attribute/.style={attribute ,dashed}} \tikzset{total/.style={double distance=1.5pt}}
\tikzset{every entity/.style={draw=orange, fill=orange!20}}
\tikzset{every attribute/.style={draw=mediumpurple, fill=mediumpurple!20}} \tikzset{every relationship/.style={draw=Chartreuse2, fill=Chartreuse2!20}} \newcommand{\key}[1]{\underline{#1}}

\definecolor{mediumpurple}{rgb}{0.58, 0.44, 0.86}
\definecolor{Chartreuse2}{rgb}{0.5, 1.0, 0.0}
\begin{document}

\maketitle
\tableofcontents
\newpage

\section{Ingegneria e sviluppo}
\subsection{Organizzazione del processo di sviluppo}

\paragraph{Decisioni organizzative}
La dimensione del team di sviluppo --- tre persone --- e i diversi livelli di interesse relativi agli `ambiti' di programmazione concernenti tale progetto, espressi inizialmente dai soggetti del team, hanno portato alla decisione di suddividere in modo moderatamente netto i compiti assegnati alle diverse persone, perlomeno nella fase iniziale, pre-design. 

Specificatamente, la decisione è stata quella di assegnare a Marian il compito di creare e sviluppare la interfacce grafiche di tutti i componenti costituenti il sistema nel suo complesso e quello di ideare e sviluppare la GUI generale, e in particolar modo di considerare i modi con cui gli utenti si aspettano di interagire con il sistema e quindi di sviluppare accordatamente le relative interfacce grafiche.

Ad Elia ed Edoardo invece è stato assegnato il compito di progettare e sviluppare la back-end, l'architettura del sistema generale e le interfacce di comunicazione e interazione dei diversi componenti. Pur non avendo definito inizialmente la suddivisione ulteriore di questi compiti, nel corso del processo di sviluppo e programmazione del sistema, a seguito della fase di progettazione in cui si sono prese decisioni relative a quali design patterns usare, la progettazione dell'architettura è stata a grandi linee divisa in due aree: lo sviluppo dei controllori e dei modelli dei componenti, secondo il pattern MVC, assegnata ad Elia, e lo sviluppo e gestione dello stato centralizzato, propagato poi seguendo il pattern Observer, assegnata invece ad Edoardo. Data la fondamentale connessione tra tali due aree da un certo punto in poi lo sviluppo dell'architettura, e in particolar modo dell'interfaccia di comunicazione tra stato e controllori dei componenti, è stata eseguita in modo unico dai i due membri del team che hanno seguito quasi esclusivamente la tecnica del \textit{dual programming}, che ha portato a scrivere gran parte del codice insieme, a turno, uno con l'input dell'altro: questo sia per permettere di migliorare la comprensione dell'architettura nel suo complesso e delle interazioni tra le parti, sia per permettere di sviluppare codice che sin da subito rispettasse i due diversi approcci di programmazione e che unisse nel modo più chiaro possibile le interfacce tra le due aree.

\paragraph{Gestione del codice} Per permettere, soprattutto inizialmente, a tutti i membri del team di contribuire al progetto in modo personale senza creare conflitti nel codice si è deciso sin da subito di utilizzare un sistema di versionamento: la scelta è ricaduta subito su \textit{Git}, data la sua ubiquità e portabilità, installato localmente sulle macchine dei membri del team e riferente una repository remota privata localizzata su \textit{Github}. Oltre che a permettere di evitare conflitti e di mantenere coerente lo stato del progetto per tutti i membri questa scelta è stata molto importante soprattutto per risolvere diversi problemi relativi all'installazione e utilizzo di un programma per la gestione del database: l'uso di diverse \textit{branches}, utilizzate anche per lo sviluppo di parti sperimentali del sistema, ha permesso lo sviluppo in contemporanea, almeno fino alla risoluzione di tutti i problemi di installazione e configurazione, del codice concernente la gestione del database e di quello relativo alle interfacce grafiche e i loro controllori.

\paragraph{Gestione dei dati} La chiara natura relazionale dei dati necessari per il funzionamento del sistema ha subito portato alla decisione di affidarsi ad un RDBMS per la loro gestione, e in particolare a PostgreSQL; tale scelta è stata motivata principalmente dalla previa esperienza di utilizzo di un membro del team. Oltre che ad utilizzare un RBDMS si è inoltre deciso di affidarsi ad un ORM --- Hibernate --- per il mapping tra entità nel database e oggetti in memoria: questa decisione è derivata soprattutto dalla volontà di mantenere semplice la logica del sistema che, per sua natura e limitata dimensione, non ha mai richiesto la maggior efficienza derivante dall'utilizzo di pure query SQL. 

\subsubsection{Ingegneria dei requisiti}
Data la natura didattica del progetto non si sono seguite le classiche tecniche di elicitazione dei requisiti ma essi sono stati ricavati e studiati a partire dalla specifica di consegna, considerata, almeno in parte, come documento dei requisiti. La stesura iniziale delle principali funzionalità, sotto forma di un provvisorio schema dei casi d'uso, è stata eseguita nella fase di pre-design da parte di tutti i membri del team basandoci appunto su tale documento dei requisiti.

Nel corso dello sviluppo del progetto, a seconda delle diverse funzionalità da implementare, sono anche stati stilati diversi casi d'uso per i vari utenti finali secondo un processo simile a quello adottato dai modelli agili: prima di implementare funzionalità specifiche del sistema si è pensato ad almeno un caso d'uso reale di tali funzionalità per permettere poi un'implementazione quanto più semplice, naturale e rispettante le aspettative e necessità degli utenti.

Di seguito parte dei casi d'uso utilizzati, aggregati per chiarezza nei vari utenti finali.

\begin{usecase}
	\addtitle{Caso d'uso}{Compilazione lettera di dimissioni}
	\addfield{Utente:}{Primario}
	\addfield{Precondizioni:}{Il primario deve essersi autenticato}
	\additemizedfield{Passi}{
		\item Nel propria dashboard seleziona la finestra per compilare le lettere di dimissione
		\item Seleziona da un menù a tendina i ricoveri dei pazienti in attesa di essere dimessi
		\item Visualizza nella schermata i dati sommari del ricovero e compila la lettera di dimissione
	}
	\addfield{Postcondizioni:}{Il paziente viene dimesso e il suo ricovero non compare più nel menù}
	
\end{usecase}


\begin{usecase}
\addtitle{Caso d'uso}{Visualizzazione e stampa dei reports dei ricoveri}
\addfield{Utente:}{Primario}
\addfield{Precondizioni:}{Il primario deve essersi autenticato}
\additemizedfield{Passi}{
	\item Nella propria dashboard seleziona la finestra per visualizzare i reports dei ricoveri settimanali
	\item Seleziona da un menù a tendina, o tramite ricerca, i ricoveri settimanali, attivi o non attivi 
	\item Visualizza nella schermata i dati sommari dei ricoveri e dei pazienti. Eventualmente può stampare tali report cliccando su un bottone che genera un documento pdf
}
\addfield{Postcondizioni:}{Vengono visualizzati i reports dei ricoveri settimanali. Se il primario ha premuto il bottone per stamparli, viene generato un documento pdf con i dati richiesti}

\end{usecase}

\begin{usecase}
	\addtitle{Caso d'uso}{Visualizzazione dati dei pazienti ricoverati (ultime due ore)}
	\addfield{Utente:}{Primario, medico, infermiere}
	\addfield{Precondizioni:}{L'utente deve essersi autenticato}
	\additemizedfield{Passi}{
		\item Nella propria dashboard l'utente seleziona la finestra per visualizzare i dati dei pazienti ricoverati
		\item L'utente visualizza, in una tabella, i dati aggiornati in tempo reale, ed esclusivi delle ultime due ore, di tutti i pazienti ricoverati attualmente
	}
	\addfield{Postcondizioni:}{L'utente visualizza le informazioni, non più vecchie di due ore, sui parametri vitali dei pazienti ricoverati}
\end{usecase}

\begin{usecase}
	\addtitle{Caso d'uso}{Spegnimento allarme}
	\addfield{Utente:}{Medico}
	\addfield{Precondizioni:}{Deve essere partito un allarme}
	\additemizedfield{Passi}{
		\item Prende atto della patologia segnalata e del paziente in questione
		\item Indica le attività svolte per portare il paziente alla normalità
		\item \begin{enumerate}
			\item se è gia autenticato, spegne l'allarme
			\item se non è autenticato, spegne l'allarme indicando le proprie credenziali
		\end{enumerate}
	}
	\addfield{Postcondizioni:}{L'allarme viene spento. Se il medico non era autenticato e ha inserito correttamente le sue credenziali rimarrà autenticato per un certo periodo di tempo}
	
\end{usecase}
\vspace{2cm}

\begin{usecase}
	\addtitle{Caso d'uso}{Ammissione dei pazienti in attesa}
	\addfield{Utente:}{Medico}
	\addfield{Precondizioni:}{Il medico deve essersi autenticato; un infermiere deve avere aggiunto i dati anagrafici dei pazienti in attesa di ricovero}
	\additemizedfield{Passi}{
		\item Nella propria dashboard selezione la finestra per visualizzare i pazienti in attesa di ricovero
		\item Da un menù a tendina sceglie tra i diversi pazienti, visualizzando, a seconda della selezione, informazioni sommarie sul paziente
		\item Se accetta di ammetterlo, da un campo di testo inserisce la diagnosi e preme un bottone di conferma
		\begin{enumerate}
			\item se il numero di pazienti attualmente ricoverati è minore di dieci, viene ammesso;
			\item altrimenti compare una finestra di errore
		\end{enumerate}
	}
	\addfield{Postcondizioni:}{Se il numero di pazienti attualmente ricoverati è minore di dieci e ha accettato di ammetterne uno inserendo la diagnosi, allora il nome del paziente scompare dal menù a tendina ed esso sarà compreso tra quelli ricoverati.}
	
\end{usecase}

\begin{usecase}
	\addtitle{Caso d'uso}{Aggiunta di prescrizioni}
	\addfield{Utente:}{Medico}
	\addfield{Precondizioni:}{Il medico deve essersi autenticato; il paziente a cui si aggiunge una prescrizione deve essere ricoverato}
	\additemizedfield{Passi}{
		\item Nella propria dashboard seleziona la finestra per aggiungere una prescrizione
		\item Da un menù a tendina sceglie tra i diversi pazienti attualmente ricoverati, visualizzando, a seconda della selezione, informazioni sommarie sul paziente
		\item In diversi campi di testo aggiunge il nome del medicinale, la dose giornaliera, la quantità per dose e la durata della terapi e preme il bottone di conferma
	}
	\addfield{Postcondizioni:}{La prescrizione viene aggiunta a quelle associate al paziente ricoverato.}
	
\end{usecase}
\subsubsection{Design del sistema}
La scelta di design è avvenuta inizialmente a tavolino tra tutti i membri del team.
%
%\subsubsection{Implementazione}
%
%\subsubsection{Verifica e convalida}
%\subsection{Design e struttura del sistema}
%
%\section{Specifica del sistema}

\section{Specifica}
\subsection{Casi d'uso}
\begin{figure}[b]
\begin{tikzpicture}
\begin{umlsystem}[x=0, fill=red!5]{Casi d'uso}
\umlusecase[x=1, y=-2.5]{Inserisce dati anagrafici del paziente}
\umlusecase[ x=.95, y=-1]{Inserisce dati somministrazione}
\umlusecase[x=4.8, ]{Inserisce note stato paziente}
\umlusecase[y=-6.2, x =2.6]{Visualizza dati paziente (ultime due ore)}
\umlusecase[x=5, y=-5]{Inserisce diagnosi d'ingresso}
\umlusecase[x=5.7, y=-3.7]{Aggiunge prescrizioni}
\umlusecase[x=6,  y=-7.5]{Spegne allarmi}
\umlusecase[x=.6, y=-9.4]{Visualizza/stampa reports pazienti}
\umlusecase[x=0, y=-10.8]{Compila lettera di dimissioni}
\end{umlsystem}

\umlactor[x=-5.5, y=-1.6]{Infermiere}
\umlactor[x=-5.5, y=-9.7]{Primario}
\umlactor[x=10.4, y=-5.7]{Medico}

\umlassoc{Infermiere}{usecase-1}
\umlassoc{Infermiere}{usecase-2}
\umlassoc{Infermiere}{usecase-4}

\umlassoc{Medico}{usecase-4}
\umlassoc{Medico}{usecase-5}
\umlassoc{Medico}{usecase-6}
\umlassoc{Medico}{usecase-7}

\umlassoc{Primario}{usecase-4}
\umlassoc{Primario}{usecase-8}
\umlassoc{Primario}{usecase-9}
\umlVHinclude{usecase-1}{usecase-5}
%\umlassoc{subuser}{usecase-3}
%\umlassoc{admin}{usecase-5}
%\umlassoc{admin}{usecase-6}
\umlinclude{usecase-2}{usecase-6}
\node at(4.1, -3.05) {$\ll$include$\gg$};
\umlVHextend{usecase-3}{usecase-2}
%\umlinclude[name=incl]{usecase-3}{usecase-4}
%
%\umlnote[x=7, y=-7]{incl-1}{note on include dependency}
\end{tikzpicture}\caption{Diagramma UML dei casi d'uso del sistema.}\label{useDiagram}
\end{figure}

\subsection{Diagrammi di classe}
\begin{figure}
	\begin{center}
		\begin{tikzpicture}
		\begin{umlpackage}[ x=0, y=0]{State}
		\umlclass[x=5.5, template={C}]{Store} {- s: State\\- r: Reducer \\- m: Middleware}{+ poll(): State \\ + update(com: C)}
		
		\umlinterface[x=0, y=-3, template={C}]{Reducer}{}{+ run(s: State, c: C): State \\+ with(s: String, f: Function) }
		\umlsimpleclass[x=0, y=-6]{ReducerString}{}{}
		
		\umlinterface[x=11, y=-3 , template={C}]{Middleware}{}{+ run(s: State, c: C) \\ + with(s: String, f: Function)}
		\umlsimpleclass[x=11, y=-6]{MiddlewareString}{}{}
		
		\umlsimpleclass[x=5.5, y=-3.5]{State} {}{}
		\umlsimpleclass[x=5.5, y=-6, template={C}]{StateEvent}{}{}
		
		\umlinterface[ y=-9, x=5.5]{Command}{}{+ name(): String \\+ getArg(): Object}
		\umlsimpleclass[x=0.2, y=-9]{StringCommand}
		
		\umlsimpleclass[x=11.8, y=0]{DatabaseService}{}{}
		
		\umlreal[]{MiddlewareString}{Middleware}
		\umlreal[]{ReducerString}{Reducer}
		\umlreal[]{StringCommand}{Command}
		\umldep[geometry=-|-]{Reducer}{Store}
		\umldep[geometry=-|-]{Middleware}{Store}
		\umldep[geometry=-|]{State}{Store}
		\umldep[]{State}{StateEvent}
		\umldep[]{Command}{StateEvent}
		\end{umlpackage}  
		
		\end{tikzpicture}
	\end{center}\caption{Diagramma di classe del \textit{package} State.}\label{StateClassDiagram}
\end{figure}

\begin{figure}
	\begin{center}
		\begin{tikzpicture}
		\begin{umlpackage}[ x=0, y=0]{Generator}
		
		\umlinterface[x=6.25, y=0]{GeneratorInterface}{}{+ reset() \\ + evolve(sick: Sickness) \\ + getValue(): Object}
	
		
		\umlclass[x=0, y=-4]{BPGenerator}{- canGenerateAlarm \\ - meanS \\ - meanD \\ - varianceS \\ - varianceD}{}
		\umlclass[x=6.25, y=-4]{TemperatureGenerator}{- canGenerateAlarm \\ - mean \\ - variance}{}
		\umlclass[x=12.5, y=-4]{HeartrateGenerator}{- canGenerateAlarm \\ - mean \\ - variance}{}
		\umlreal[geometry=|-]{BPGenerator}{GeneratorInterface}
		\umlreal[geometry=|-]{HeartrateGenerator}{GeneratorInterface}
		\umlreal[]{TemperatureGenerator}{GeneratorInterface}
		\end{umlpackage}  
		
		\end{tikzpicture}
	\end{center}\caption{Diagramma di classe del \textit{package} Generator.}\label{GeneratorClassDiagram}
\end{figure}

\begin{figure}
	\begin{center}
		\begin{tikzpicture}
		\begin{umlpackage}[ x=0, y=0]{HPInterfaceFactory}
		\umlclass[x=7, y=3.5]{HPFactory}{}{+ getHPFactory(s: String)}
		\umlinterface[x=7, y=0]{HPInterface}{}{+ getFile() : String }
		
		\umlsimpleclass[x=0, y=-3]{HPDefault}
		\umlsimpleclass[x=4.4, y=-3]{HPMonitoring}
		\umlsimpleclass[x=9.2, y=-3]{HPSearch}
		\umlsimpleclass[x=13.2, y=-3]{HPSearchResult}
		
		\umlimpl[geometry=|-]{HPDefault}{HPInterface}
		\umlimpl{HPMonitoring}{HPInterface}
		\umlimpl{HPSearch}{HPInterface}
		\umlimpl[geometry=|-]{HPSearchResult}{HPInterface}
		\end{umlpackage}  
		
		\end{tikzpicture}
	\end{center}\caption{Diagramma di classe del \textit{package} HPInterfaceFactory.}\label{HpInterfaceFactoryClassDiagram}
\end{figure}

\begin{figure}
	\begin{center}
\begin{tikzpicture}[node distance=7em]
\node[entity] at (0,0) (patient) {Patient};
\node[relationship] (riceve) at(3.2,0) {receives} edge (patient); 
\node[entity] (administration) at (6.7,0) {Administration} edge (riceve); 
\node[relationship] (has) [below of=administration] {has} edge(administration);
\node[entity] (prescription) [below of=has] {Prescription} edge(has);
\node[relationship] (comprehends) at (3.2,-5) {includes} edge(prescription);
\node[entity] (recovery) at (0, -5) {Recovery} edge(comprehends);
\node[relationship] (getput) [below of=patient] {gets put} edge(patient) edge(recovery);
\node[relationship] (includes) [below of=recovery] {includes} edge(recovery);
\node[entity] (monitoring) [below of=includes] {Monitoring} edge(includes);

\node at (1.1,0.25) {1};
\node at (5.1,0.25) {n};

\node at (6.95,-0.8) {n};
\node at (6.95,-4.1) {1};

\node at (0.3,-0.8) {1};
\node at (0.3,-4.2) {n};

\node at (1.2,-4.7) {1};
\node at (5.3,-4.7) {n};

\node at (0.3,-5.8) {1};
\node at (0.3,-9.2) {n};

\end{tikzpicture}
	\end{center}
	\caption{Schema \textit{Entity-Relationship} dei dati del sistema.}\label{ERdiagram}
\end{figure}
\begin{table}
	\begin{tabular}{r | l}
		Entità & Campi \\ \hline
		Patient & \underline{Id}, Name, Surname, Fiscal code, Place of birth, Date of birth \\
		Administration & \underline{Id}, Date, Hour, Dose, Notes, \textit{Patient}, \textit{Prescription} \\
		Prescription & \underline{Id}, Drug, Duration, Daily dose, Number of doses, Doctor, \textit{Recovery} \\ 
		Recovery & \underline{Id}, Start date, End date, Diagnosis, Active, Discharge summary, \textit{Patient}\\
		Monitoring & \underline{Id}, Date, Diastolic pressure, Systolic pressure, Heart rate, Temperature, \textit{Recovery}
	\end{tabular}\caption{Campi e relazioni delle entità del database. I campi sottolineati indicano le \textit{primary keys}, quelli in corsivo le \textit{foreign keys} (mappate sempre ai campi Id della rispettiva entità).}
\end{table}


\end{document}
