\documentclass[final]{svjour3}
%opening
\usepackage[11pt]{extsizes}
\usepackage[top=2cm,bottom=3cm,left=2.3cm,right=2.3cm]{geometry}

\title{Relazione progetto di Ingegneria del software 2019}
\author{Edoardo Zorzi, Elia Piccoli, Marian Statache}
\date{Luglio 2019}
\usepackage{tikz}
\usepackage{xcolor}
\usepackage{pgfopts}
\usepackage{./tikz-uml}
\usepackage[latin1]{inputenc}
\usepackage[italian]{babel}
\usepackage[T1]{fontenc}
\usetikzlibrary{automata ,shapes, er}
\usepackage{dot2texi}
\usepgfmodule{oo}
\usepackage{./usecases}
\tikzset{multi attribute/.style={attribute,double distance=1.5pt}} \tikzset{derived attribute/.style={attribute ,dashed}} \tikzset{total/.style={double distance=1.5pt}}
\tikzset{every entity/.style={draw=orange, fill=orange!20}}
\tikzset{every attribute/.style={draw=mediumpurple, fill=mediumpurple!20}} \tikzset{every relationship/.style={draw=Chartreuse2, fill=Chartreuse2!20}} \newcommand{\key}[1]{\underline{#1}}

\definecolor{mediumpurple}{rgb}{0.58, 0.44, 0.86}
\definecolor{Chartreuse2}{rgb}{0.5, 1.0, 0.0}
\begin{document}

\maketitle
\tableofcontents
\newpage

\section{Ingegneria e sviluppo}
\subsection{Organizzazione del processo di sviluppo}

\paragraph{Decisioni organizzative}
La dimensione del team di sviluppo --- tre persone --- e i diversi livelli di interesse relativi agli `ambiti' di programmazione concernenti tale progetto, espressi inizialmente dai soggetti del team, hanno portato alla decisione di suddividere in modo moderatamente netto i compiti assegnati alle diverse persone, perlomeno nella fase iniziale, pre-design. 

Specificatamente, la decisione è stata quella di assegnare a Marian il compito di creare e sviluppare la interfacce grafiche di tutti i componenti costituenti il sistema nel suo complesso e quello di ideare e sviluppare la GUI generale, e in particolar modo di considerare i modi con cui gli utenti si aspettano di interagire con il sistema e quindi di sviluppare accordatamente le relative interfacce grafiche.

Ad Elia ed Edoardo invece è stato assegnato il compito di progettare e sviluppare la back-end, l'architettura del sistema generale e le interfacce di comunicazione e interazione dei diversi componenti. Pur non avendo definito inizialmente la suddivisione ulteriore di questi compiti, nel corso del processo di sviluppo e programmazione del sistema, a seguito della fase di progettazione in cui si sono prese decisioni relative a quali design patterns usare, la progettazione dell'architettura è stata a grandi linee divisa in due aree: lo sviluppo dei controllori e dei modelli dei componenti, secondo il pattern MVC, assegnata ad Elia, e lo sviluppo e gestione dello stato centralizzato, propagato poi seguendo il pattern Observer, assegnata invece ad Edoardo. Data la fondamentale connessione tra tali due aree da un certo punto in poi lo sviluppo dell'architettura, e in particolar modo dell'interfaccia di comunicazione tra stato e controllori dei componenti, è stata eseguita in modo unico dai i due membri del team che hanno seguito quasi esclusivamente la tecnica del \textit{dual programming}, che ha portato a scrivere gran parte del codice insieme, a turno, uno con l'input dell'altro: questo sia per permettere di migliorare la comprensione dell'architettura nel suo complesso e delle interazioni tra le parti, sia per permettere di sviluppare codice che sin da subito rispettasse i due diversi approcci di programmazione e che unisse nel modo più chiaro possibile le interfacce tra le due aree.

\paragraph{Gestione del codice} Per permettere, soprattutto inizialmente, a tutti i membri del team di contribuire al progetto in modo personale senza creare conflitti nel codice si è deciso sin da subito di utilizzare un sistema di versionamento: la scelta è ricaduta subito su \textit{Git}, data la sua ubiquità e portabilità, installato localmente sulle macchine dei membri del team e riferente una repository remota privata localizzata su \textit{Github}. Oltre che a permettere di evitare conflitti e di mantenere coerente lo stato del progetto per tutti i membri questa scelta è stata molto importante soprattutto per risolvere diversi problemi relativi all'installazione e utilizzo di un programma per la gestione del database: l'uso di diverse \textit{branches}, utilizzate anche per lo sviluppo di parti sperimentali del sistema, ha permesso lo sviluppo in contemporanea, almeno fino alla risoluzione di tutti i problemi di installazione e configurazione, del codice concernente la gestione del database e di quello relativo alle interfacce grafiche e i loro controllori.

\paragraph{Gestione dei dati} La chiara natura relazionale dei dati necessari per il funzionamento del sistema ha subito portato alla decisione di affidarsi ad un RDBMS per la loro gestione, e in particolare a PostgreSQL; tale scelta è stata motivata principalmente dalla previa esperienza di utilizzo di un membro del team. Oltre che ad utilizzare un RBDMS si è inoltre deciso di affidarsi ad un ORM --- Hibernate --- per il mapping tra entità nel database e oggetti in memoria: questa decisione è derivata soprattutto dalla volontà di mantenere semplice la logica del sistema che, per sua natura e limitata dimensione, non ha mai richiesto la maggior efficienza derivante dall'utilizzo di pure query SQL. 

\subsubsection{Ingegneria dei requisiti}
Data la natura didattica del progetto non si sono seguite le classiche tecniche di elicitazione dei requisiti ma essi sono stati ricavati e studiati a partire dalla specifica di consegna, considerata, almeno in parte, come documento dei requisiti. La stesura iniziale delle principali funzionalità, sotto forma di un provvisorio schema dei casi d'uso, è stata eseguita nella fase di pre-design da parte di tutti i membri del team basandoci appunto su tale documento dei requisiti.

Nel corso dello sviluppo del progetto, a seconda delle diverse funzionalità da implementare, sono anche stati stilati diversi casi d'uso per i vari utenti finali secondo un processo simile a quello adottato dai modelli agili: prima di implementare funzionalità specifiche del sistema si è pensato ad almeno un caso d'uso reale di tali funzionalità per permettere poi un'implementazione quanto più semplice, naturale e rispettante le aspettative e necessità degli utenti.

Di seguito parte dei casi d'uso sviluppati.
\begin{usecase}
	\addtitle{Caso d'uso}{Inserimento dei dati anagrafici di un paziente}
	\addfield{Utente:}{Infermiere}
	\addfield{Precondizioni:}{L'infermiere deve essersi autenticato}
	\additemizedfield{Passi}{\item cao 1 }
	
	\addfield{Postcondizioni:}{Il paziente deve essere inserito nel sistema, senza associato ricovero}
\end{usecase}

%\subsubsection{Design del sistema}
%
%\subsubsection{Implementazione}
%
%\subsubsection{Verifica e convalida}
%\subsection{Design e struttura del sistema}
%
%\section{Specifica del sistema}

\section{Specifica}
\subsection{Casi d'uso}
\begin{figure}[b]
\begin{tikzpicture}
\begin{umlsystem}[x=0, fill=red!5]{Casi d'uso}
\umlusecase[x=1.9, y=-2.]{Inserisce dati anagrafici del paziente}
\umlusecase[ x=.95]{Inserisce dati somministrazione}
\umlusecase[x=5.8, y=-1,]{Inserisce note stato paziente}
\umlusecase[y=-5, x =1.3]{Visualizza dati paziente (ultime due ore)}
\umlusecase[x=3.9, y=-4]{Inserisce diagnosi d'ingresso}
\umlusecase[x=3.5, y=-6.3]{Aggiunge prescrizioni}
\umlusecase[x=3.5,  y=-7.5]{Spegne allarmi}
\umlusecase[x=.6, y=-9.4]{Visualizza/stampa reports pazienti}
\umlusecase[x=0, y=-10.8]{Compila lettera di dimissioni}
\end{umlsystem}

\umlactor[x=-5.5]{Infermiere}
\umlactor[x=-5.5, y=-9.7]{Primario}
\umlactor[x=10.9, y=-5.7]{Medico}

\umlassoc{Infermiere}{usecase-1}
\umlassoc{Infermiere}{usecase-2}
\umlassoc{Infermiere}{usecase-4}

\umlassoc{Medico}{usecase-4}
\umlassoc{Medico}{usecase-5}
\umlassoc{Medico}{usecase-6}
\umlassoc{Medico}{usecase-7}

\umlassoc{Primario}{usecase-4}
\umlassoc{Primario}{usecase-8}
\umlassoc{Primario}{usecase-9}
%\umlassoc{subuser}{usecase-3}
%\umlassoc{admin}{usecase-5}
%\umlassoc{admin}{usecase-6}
\umlinherit{usecase-5}{usecase-1}
\umlVHextend{usecase-3}{usecase-2}
%\umlinclude[name=incl]{usecase-3}{usecase-4}
%
%\umlnote[x=7, y=-7]{incl-1}{note on include dependency}
\end{tikzpicture}\caption{Diagramma UML dei casi d'uso del sistema.}\label{useDiagram}
\end{figure}

\subsection{Diagrammi di classe}
\begin{figure}[t]
\begin{center}
	\begin{tikzpicture}
\begin{umlpackage}[ x=0, y=0]{State}
\umlclass[x=5.5, template={C}]{Store} {- s: State\\- r: Reducer \\- m: Middleware}{+ poll(): State \\ + update(com: C)}

\umlinterface[x=0, y=-3, template={C}]{Reducer}{}{+ run(s: State, c: C): State \\+ with(s: String, f: Function) }
\umlsimpleclass[x=0, y=-6]{ReducerString}{}{}

\umlinterface[x=11, y=-3 , template={C}]{Middleware}{}{+ run(s: State, c: C) \\ + with(s: String, f: Function)}
\umlsimpleclass[x=11, y=-6]{MiddlewareString}{}{}

\umlsimpleclass[x=5.5, y=-3.5]{State} {}{}
\umlsimpleclass[x=5.5, y=-6, template={C}]{StateEvent}{}{}

\umlinterface[ y=-9, x=3]{Command}{}{+ name(): String \\+ getArg(): Object}
\umlsimpleclass[x=3, y=-12]{StringCommand}

\umlsimpleclass[x=9, y=-9]{DatabaseService}{}{}

\umlreal[]{MiddlewareString}{Middleware}
\umlreal[]{ReducerString}{Reducer}
\umlreal[]{StringCommand}{Command}
\umldep[geometry=-|-]{Reducer}{Store}
\umldep[geometry=-|-]{Middleware}{Store}
\umldep[geometry=-|]{State}{Store}
\umldep[]{State}{StateEvent}
\umldep[]{Command}{StateEvent}
\end{umlpackage}  
	
\end{tikzpicture}
\end{center}\caption{Diagramma di classe del \textit{package} State.}\label{StateClassDiagram}
\end{figure}

\newpage
\begin{figure}
	\begin{center}
\begin{tikzpicture}[node distance=7em]
\node[entity] at (0,0) (patient) {Patient};
\node[relationship] (riceve) at(3.2,0) {receives} edge (patient); 
\node[entity] (administration) at (6.7,0) {Administration} edge (riceve); 
\node[relationship] (has) [below of=administration] {has} edge(administration);
\node[entity] (prescription) [below of=has] {Prescription} edge(has);
\node[relationship] (comprehends) at (3.2,-5) {includes} edge(prescription);
\node[entity] (recovery) at (0, -5) {Recovery} edge(comprehends);
\node[relationship] (getput) [below of=patient] {gets put} edge(patient) edge(recovery);
\node[relationship] (includes) [below of=recovery] {includes} edge(recovery);
\node[entity] (monitoring) [below of=includes] {Monitoring} edge(includes);

\node at (1.1,0.25) {1};
\node at (5.1,0.25) {n};

\node at (6.95,-0.8) {n};
\node at (6.95,-4.1) {1};

\node at (0.3,-0.8) {1};
\node at (0.3,-4.2) {n};

\node at (1.2,-4.7) {1};
\node at (5.3,-4.7) {n};

\node at (0.3,-5.8) {1};
\node at (0.3,-9.2) {n};

\end{tikzpicture}
	\end{center}
	\caption{Schema \textit{Entity-Relationship} dei dati del sistema.}\label{ERdiagram}
\end{figure}
\begin{table}
	\begin{tabular}{r | l}
		Entità & Campi \\ \hline
		Patient & \underline{Id}, Name, Surname, Fiscal code, Place of birth, Date of birth \\
		Administration & \underline{Id}, Date, Hour, Dose, Notes, \textit{Patient}, \textit{Prescription} \\
		Prescription & \underline{Id}, Drug, Duration, Daily dose, Number of doses, Doctor, \textit{Recovery} \\ 
		Recovery & \underline{Id}, Start date, End date, Diagnosis, Active, Discharge summary, \textit{Patient}\\
		Monitoring & \underline{Id}, Date, Diastolic pressure, Systolic pressure, Heart rate, Temperature, \textit{Recovery}
	\end{tabular}\caption{Campi e relazioni delle entità del database. I campi sottolineati indicano le \textit{primary keys}, quelli in corsivo le \textit{foreign keys} (mappate sempre ai campi Id della rispettiva entità).}
\end{table}


\end{document}
